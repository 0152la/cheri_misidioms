%&cheri_misidioms_preamble
\endofdump

\begin{document}


\begin{abstract}
\noindent
Several memory allocators have been ported to CHERI, a hardware capability
platform. In this paper we examine the security and performance of these
allocators. We show that the allocators are subject to simple security vulnerabilities,
which we categorise and explain. However, we show that it is difficult
to make statements about performance, because compilers adapted to CHERI do not optimise code
as fully as one would hope, particularly in idioms that are common in allocators,
leading to a muddled performance picture.
\end{abstract}

\maketitle

\section{Introduction}

Capability Hardware Enhanced RISC Instructions
(CHERI)~\cite{watson20cheriintroduction} provides and enforces hardware
capabilities that allow programmers to make strong security guarantees
about the memory safety properties of their programs. However, capabilities are
not magic. Programmers must first decide which memory safety properties they
wish to enforce and then write their software in a way that enforces those properties.
It is easy for mistakes to creep in during either step, undermining
the security guarantees programmers believe their code possesses.

In this paper we examine one of the most fundamental software components:
memory allocators (henceforth just ``allocators''). Apart from some embedded
systems (which preallocate fixed quantities of memory), allocators are
ubiquitous, because they allow us to write programs that are generic over a
variety of memory usage patterns. Since allocators are used so frequently,
their performance and security properties are a major part of the
performance and security properties of software in general. In other words,
slow memory allocators and/or those with security flaws have significant
and widespread consequences.

In this paper we examine allocators and pure capability CHERI from both performance
and security angles. In Section~\ref{sec:atk} we introduce a number of `attacks' and
show that many of the allocators are vulnerable to at least some of the attacks
(note that since we first made a pre-print of this paper available, some
allocators have fixed some or all vulnerabilities). In
Section~\ref{performance} we attempt to examine the performance of CHERI
allocators. To our surprise, it is difficult to draw meaningful conclusions. We
show that compilers on CHERI platforms do not optimise code as fully as one
would expect, leading to a muddled performance picture.

We do not claim our work is definitive, though it does suggest two things:
that some allocators undermine the security properties one might
expect from software running on pure capability CHERI; and that it is
currently difficult to reason about the performance of software on CHERI.


\section{Background}

We expect that few readers are expert in both CHERI and allocators: in this
section, we first provide a brief overview of CHERI (Section~\ref{sec:cheri}),
before introducing a very basic CHERIfied allocator (Section~\ref{sec:bumppointerallocator}).


\subsection{CHERI}
\label{sec:cheri}

In this subsection,
we provide a simple overview of CHERI, and its major concepts.
Because CHERI has been developed over a number of years, and is explained over
a variety of documentation and papers, some concepts have acquired more than one name,
and/or have names which subtly conflict with definitions common in mainstream
software development. We use a single name for each concept, sometimes
introducing new names where we believe that makes things clearer.

A \emph{capability} is a token that gives those who bear it the ability to
perform certain actions. By restricting who has access to a given capability,
one can enforce security properties (e.g.~`this part of the software can
only read from heap memory'). Capabilities have a long and storied history: \cite{levy84capability}
provides an approachable historical overview of capability architectures, and
may usefully be augmented by more recent work such as~\cite{miller06robust}.
A good first intuition is that CHERI is a modern update of this venerable
idea, updated with fine-grained permissions, and adapted to work on modern
processor instruction sets.

We use the term \emph{CHERI} to refer to the `abstract capability machine'
that software can observe: that is, the combination of a capability hardware
instruction set, an ABI (e.g.~\cite{brooks19cheriabi}), a user-facing library that exposes
capability-related functions, and a CHERI-aware language. (e.g.~CHERI C~\cite{watson20chericprogramming}).
We refer to specific hardware implementations by
their name (e.g.~Arm's `Morello', an extension of the AArch64 instruction
set, or `CHERI RISC-V').

A fundamental property of CHERI capabilities is that they cannot be forged. Each
new \emph{child} capability must be derived from one or more \emph{parent}
capabilities. An \emph{authentic}\footnote{CHERI calls these
`tagged' or `valid' (and their inauthentic counterparts `untagged' or `invalid').}
capabilityÂ is one that has been derived from authentic parents according to
CHERI's rules. Attempts to create capabilities by other means produce
\emph{inauthentic} results.

A capability consists of an
\emph{address} in memory and a set of \emph{permissions} (only a subset of
which we consider in this paper). Amongst the permissions are \emph{bounds} -- the region of memory an
authentic capability is allowed to read/write from/to. A capability's bounds
are from a \emph{low} (inclusive) to a \emph{high} (exclusive) address and we
refer to `a bound of $x$ bytes' to mean a capability where
$\textit{high}-\textit{low}=x$. An address, or range or addressses, is
\emph{in-bounds} for a given capability if it is wholly contained within the
capability's bounds, or \emph{out-of-bounds} otherwise. The
capability as a whole is considered \emph{in-bounds} or \emph{out-of-bounds} if
its inherent (singular) address is in-bounds or out-of-bounds, respectively.
See~\cite{woodruff19chericoncentrate} for an explanation of why an authentic
capability might have an out-of-bounds address. Other permissions include
boolean flags, for example to indicate whether a capability can read from or
write to memory addresses within its bounds.

\jacob{I plan to change our \emph{permissions} to not include the \emph{bounds},
since all other CHERI authorities seem to treat them separately, and I think
there's little value in deviating here. If anyone objects, please let me know!}

A \emph{permissions check} is said to be successful if the permission required
for a given operation is provided by a given capability.
A \emph{bounds check} is said to be successful if a given capability, address or
address range is in-bounds for a given capability.

We consider a capability to be \emph{exercised} if an operation is successfully
performed that requires authenticity, a permission check, and a bounds check
according to the operation. Failed attempts to exercise capabilities usually
result in hardware exceptions. However, some CHERI implementations instead
provide inauthentic results, where permitted by the security model. For example:
a failed attempt to exercie a capability for a sealing operation on Morello
produces an inauthentic result, rather than an exception.

\jacob{This is slightly narrower than Morello's own definition of \emph{using} a
capability, which depends only on the permissions. However, in practice, all
such uses also check authenticity and bounds, so I think our definition is more
useful. Do we all agree?}
\laurie{i'm broadly fine with this, though i think I might tweak `instead
permitted by the security model' to something like `operate on and produce
inauthentic capabilities (mostly for performance reasons) where this does not
undermine fundamental aspects of the security model (e.g.~memory safety)' to
hammer home the point}

As well as capabilities (which on Morello and CHERI RISC-V, for example, are
128 bits), CHERI also allows `traditional' single-width
pointers-as-addresses (which on Morello and CHERI RISC-V are 64-bit addresses)
to be used. Although CHERI processors allow both double-width capabilities and
single-width addresses-as-pointers to exist alongside each other at any time,
conventionally, a program which uses both traditional addresses and
capabilities is said to be operating in \emph{hybrid} mode while a program
which uses only capabilities is in \emph{pure capability} mode. In this paper
we concentrate exclusively on programs which operate in pure capability mode.

CHERI does not presuppose a particular Operating System (OS). While there is a
CHERI Linux port, at the time of writing the most mature OS for CHERI hardware
is CheriBSD, a FreeBSD descendent. In this paper we use CheriBSD exclusively.


\subsection{A Basic Pure Capability Allocator}
\label{sec:bumppointerallocator}

\begin{figure}[t]
\lstinputlisting[
  language=C,
  caption={
    A simple, but complete, non-capability aware, bump pointer allocator:
    \texttt{malloc} works as per normal; \texttt{free} is a no-op; and
    \texttt{realloc} always allocates a new chunk of memory.
    \texttt{\_\_builtin\_align\_up(v, a)} is an LLVM / clang primitive which rounds
    \texttt{v} up to the next smallest multiple of \texttt{a}: in this example,
    every memory block returned by \texttt{malloc} is sufficiently aligned to
    store a pointer.
  },
label=lst:bump_alloc1]{code/bump_alloc1.c}
\end{figure}

At a basic level, capabilities do not add substantial complexity to an
allocator. To illustrate this, we start with a simple, but complete, example of
a non-capability bump allocator in Listing~\ref{lst:bump_alloc1}: \texttt{malloc} works as per normal; \texttt{free}
is a no-op; and \texttt{realloc} always allocates a new chunk of memory. The
allocator reserves a large chunk of memory using a single \fnc{mmap} call then
doles out chunks on each \fnc{malloc} / \texttt{realloc}
calls. The bump pointer moves through the \texttt{mmap}ed chunk until it
reaches the upper limit, at which point the allocator returns \texttt{NULL}s.

\begin{figure}[t]
\lstinputlisting[language=C,
  caption={
    Replacing the non-CHERI aware \texttt{malloc} from
    Listing~\ref{lst:bump_alloc1} with a capability-aware alternative
    using the idioms suggested in~{\cite[p.~30]{watson20chericprogramming}}.
    This \texttt{malloc} returns a capability whose bounds are sufficient
    to cover \texttt{size} bytes starting at the capability's address: in other
    words, the capability returned allows the caller to access memory in the
    way they would expect..
  },
    label=lst:bump_alloc2]
  {code/bump_alloc2.c}
\end{figure}

There is no single definition of what a `capability aware' allocator should do
but, at a minimum, one might reasonably expect that \texttt{malloc} returns a
capability (rather than just a pointer) and that capability's bounds will be
restricted to the block of memory just allocated. Listing~\ref{lst:bump_alloc2}
shows how to adapt \texttt{malloc} to do this.

The code to create the capability (using the idioms suggested
in~\cite[p.~30]{watson20chericprogramming}) is more involved than one might
first expect. The underlying cause is that there aren't, and cannot reasonably
be, enough bits in CHERI's bounds to precisely represent every possible address
and size. Modern CHERI therefore uses an encoding for bounds that allows small
bounds to be precisely represented, at the expense of larger bounds becoming
progressively less precise~\cite{woodruff19chericoncentrate}. On Morello,
16,385 bytes is the smallest bound which can not be precisely represented in a
capability, and which is thus rounded up to the next representable bound (in
this case 16,392\footnote{For CHERI RISC-V the first unrepresentable length is
4,097 bytes, which is rounded up to 4,104.}). Our capability aware
\texttt{malloc} thus has to ensure that both the capability's low and high
bound addresses are rounded down and up (respectively) in a way that ensures
that the address and size can be fully covered.


\section{The Allocators under Consideration}
\label{sec:cheriallocators}

\laurie{we need to add citations for the allocators where possible}
\andrei{Currently this section talks about porting effort, some assorted
properties, and then security properties. Is this sufficient, or is there
something else?}

A number of allocators are available for CheriBSD, though they are mostly
installed via three different routes: as part of the base distribution; via
CheriBSD \emph{packages}; or via external source. The standard way to build a CheriBSD distribution is to use
the \texttt{cheribuild} tool: this also offers multiple flavours of CheriBSD,
where different flavours can, and do, include different allocators. In one case
the version of one allocator available via \texttt{cheribuild} is sufficiently
old and broken that we felt it necessary to build it directly from a GitHub
repository. When describing the set of allocators under consideration in this
paper, we therefore need to describe not just the allocator itself, but also
the route via which we obtained it.

On that basis, the allocators we consider in this paper, and the names we use
for them for the rest of this paper, are as follows:
\begin{itemize}
  \item \memalloc{jemalloc}, a modified version of the well-known \emph{jemalloc} \laurie{cite} allocator,
is the default allocator for CheriBSD.

\item \memalloc{libmalloc-simple} is \laurie{what is it?} \laurie{is it installed in the default CheriBSD distribution? how do we access it?}.

\item \memalloc{snmalloc-cheribuild} is an old version of
  \emph{snmalloc}~\cite{snmalloc} that can be installed via \texttt{cheribuild}. We
    found that this version to have several problems which we rectified by
    manually building a version from \emph{snmalloc}'s GitHub repository. We term this
    latter version \texttt{snmalloc-repo}. Note that \emph{snmalloc} has adaptions for
    CHERI included as default \laurie{I think -- please check!} \laurie{Table 1
    suggests i'm wrong as snmalloc has non-zero LoC changed}.

  \item \memalloc{dlmalloc-cheribuild} is a version of the well-known \emph{dlmalloc} allocator \laurie{cite} modified for CHERI, installable via \texttt{cheribuild}. CheriBSD's packages include \memalloc{dlmalloc-pkg64c} which is an unmodified version of dlmalloc. \laurie{are these the same `underlying' version of dlmalloc?}

\item \memalloc{ptmalloc} is \laurie{dunno}.

\item \memalloc{libxmalloc} is \laurie{dunno}.

\item \emph{musl} is an implementation of the standard C library, which includes an allocator. We found two \emph{musl} ports to CHERI on GitHub: \texttt{musl-huawei} and \texttt{musl-morello} from Huawei and Arm respectively. \laurie{i guess these two musl's aren't forked from the same underlying version?}.

\item \memalloc{newlib} is \laurie{dunno}.

\item \memalloc{bump-alloc} is the simple bump allocator from Section~\ref{sec:bumppointerallocator}.
\end{itemize}

We are aware of at least two other major memory allocators that have been
partly ported to CHERI: the \emph{Boehm-Demers-Weiser} conservative garbage
collector; and the \emph{WebKit} garbage collector. Since neither port is yet
complete, we have not included them in this paper.

\autoref{tab:allocator_summary} shows further detail about the allocators,
including the precise version we used, and their total number of Source Lines
of Code (SLoC) as calculated by the \texttt{cloc} tool. We also show
approximately what proportion of the allocator has been adapted for CHERI by
calculating the percentage of lines of code contained between \texttt{\#ifdef
CHERI} blocks. This count is an under-approximation, as some code outside such
\texttt{\#ifdef} blocks may also have been adapted, but it gives a rough idea
of the extent of changes. \laurie{what tool did we use to do the IFDEF counting?}

\laurie{i think the rest of this paragraph is out of date?}
Particularly, most allocators coming with \texttt{pkg64c}
crashed with a segmentation fault on execution of our tests. \andrei{Hopefully
we can test these shortly} Furthermore, at the moment of writing, we do not
have access to a CHERI Linux system, meaning we are unable to test the
\memalloc{musl} and \memalloc{newlib} ports.


\subsection{Existing CheriBSD allocators}
\label{sec:rqs}

\input{./data/results/slocs.tex}

How difficult is it to port a standard memory allocator to pure capability
CheriBSD\@? In this section we briefly examine several existing allocators. We
show the allocators we consider in \autoref{tab:allocator_summary}, as well as
their size, and the quantity and proportion of lines changed for the CHERI
port.

As \autoref{tab:allocator_summary} shows, with the exception of the extremely
small libmalloc-simple, the pure capability CheriBSD ports require around
0.3-0.9\% of lines to be changed. This is an order of magnitude bigger than the
0.026\% lines changed for porting a desktop environment (including X11 and
KDE)~\cite{watson21assessing}. Given the lower-level, and thus more platform
dependent, nature of memory allocators, this relative difference seems
reasonable.

\laurie{i don't think we need to go into too much detail, but there is some
value IMHO in seeing how much of the static API different allocators use.
unfortunately i don't fully understand some of the original text so the rest of
this section from this point onwards needs careful consideration.} A different
proxy for porting complexity is to measure the number of different CHERI API
calls a ported memory allocator makes use of: broadly speaking, the more of the
CHERI API is used, the harder the porting effort was likely to have been.
Comparing across the allocators is somewhat muddied because there are (at
least) three CHERI APIs in common use. This is due to the gradual evolution of
the software ecosystem over the past decade.

The most fundamental C-level API is provided by compiler builtins, such as
\texttt{\_\_builtin\_cheri\_base\_get}. There are currently 39 such builtins,
plus another four that are Morello-specific. In addition, the CHERI port of
LLVM introduces three generic builtins for managing alignment, which we do not
count as CHERI features for this analysis. Three of the memory allocators we
study -- newlib, Musl and Trivial -- make use of this
"builtin" API\@.

Another API is provided by \filename{cheric.h}. This is considered to be a
legacy, deprecated API\@. However, it is still in use, including by two of the
memory allocators we study (BSD malloc and jemalloc). \texttt{cheric.h}
provides 63 functions (or function-like macros), 29 of which are implemented as
trivial pass-throughs to compiler builtins. Several of the remaining 34
functions are fairly complicated compound operations. For example,
\texttt{cheri\_is\_subset} involves eight unique calls to four other functions.
\texttt{cheric.h} also provides some additional utilities for kernel use
(\texttt{cheri\_kern\_*}), and exposes some implementation details
(\texttt{\_\_cheri\_*}), but we disregard both subsets for this analysis.

\jacob{We should analyse how many of the cheric.h calls are to pass-through
functions, because they'll be easy to compare with cheriintrin.h
etc.}\andrei{What is a pass-through function? I can have a look}

The current preferred API is \filename{cheriintrin.h}, which provides 34
functions (or function-like macros), of which the vast majority (30) map
directly onto builtins, and the remaining four are very simple wrappers.

\jacob{Do we study anything using \texttt{cheriintrin.h}?}
\andrei{Add links/versions of these CHERI APIs we mention}

For each of the allocators, we inspect the source code to count the number of
distinct CHERI API calls. Note that if the same function is called in multiple
source code locations, we only count it once.  This gives us a static measure
of API coverage, for each allocator. \autoref{tab:rq1} shows the results,
indicating that some allocators have a broader spread of API calls. \emph{What
does this imply?} \emph{What are the API calls doing?}

\input{./data/results/cheri_api.tex}

%\begin{table}
  %\begin{center}
    %\begin{tabular}{ccrr}
    %\toprule
      %\textbf{allocator} & \textbf{API} & \textbf{\# API calls} & \textbf{API coverage} \\
      %\midrule
      %BSD malloc & cheric & 10 & 10/57 \\
      %jemalloc & cheric & 11 & 11/57 \\
      %Musl & builtin & ?? 22 or 6 ?? & 6/37 \\
      %Newlib & builtin & 9 & 9/37 \\
      %Trivial & builtin & 3 & 3/37 \\ 
      %\bottomrule
    %\end{tabular}
  %\end{center}
  %\caption{\label{tab:rq1}Coverage of CHERI API calls by various allocators}
%\end{table}

\jacob{Ok, it's time for a difficult question, sorry! Basically, why are we
asking this question (\textbf{RQ1}), and what are we hoping to learn from it?
Static API usage is relatively easy to measure, but I'm not sure what~table~\ref{tab:rq1} tells me.
Dynamic usage is more difficult to measure, but has more obvious uses (e.g.~for performance analysis).
However, for \emph{security} analysis, we probably want to count uses with the
vague property of ``sequences that require careful thought''.
Typically, it seems, these are cases affected by bounds imprecision (where
simple tests might work even for invalid code). Such sequences require significant work to
implement, and carry a greater risk of vulnerability.
For example: the bump allocator required a sequence with a critcial order of
operations, buT it was probably only a handful of API calls in the end. I think there were similar sequences in BoehmGC too.
Section~\ref{sec:atk}~goes into more detail there (by counter-example).}
\andrei{I will second this. My first impression of RQ1 was that it's more to do with performance analysis.}

\jacob{What \emph{are} the most common API calls? That was what \textbf{RQ1} asked.}


%%%


\section{Performance}
\label{performance}


\section{Security Properties}
\label{sec:rqs:rq4}

\laurie{We show that it is surprisingly difficult to make a `secure' allocator for pure
capability CHERI\@. We first show the basic problems with a simple bump-pointer
allocator example (\autoref{sec:bumppointerallocator}). We then
examine~\alloccount{} existing allocators that have been ported to CHERI
(\autoref{sec:cheriallocators}). Finally we introduce and name~\allocbugs{}
simple `attacks' on pure capability memory allocators, showing that most of the
allocators are vulnerable to most of the attacks (\autoref{sec:atk}). Since
we first made a pre-print of this paper available, some allocators have
fixed some or all vulnerabilities, but many remain vulnerable.
}

The CHERI hardware extensions supports a variety of enforceable security
policies, but these require careful coding in software.
For memory allocators, CHERI offers the possibility of:
\begin{itemize}
\item lightweight software compartmentalization
\item temporal memory safety on the heap
\item spatial memory safety on the heap
\end{itemize}

\jacob{We should define "lightweight software compartmentalization".}

\jacob{I find it useful, in general, to distinguish between language-level
temporal safety (like Rust or \fnc{unique\_ptr}) and strict temporal safety (at
the machine level). The former is sufficient for the majority of UaF
vulnerabilities, but the latter is required if the code is malicious (since
residual register values could be read by inline assembly, for example). Is that
too far for this paper?}

When we survey existing CHERI memory allocators `in-the-wild', we
see that they currently provide support for spatial memory safety
on the heap.

In terms of the Common Weakness Enumeration (CWE \andrei{cite}), all the
allocators we surveyed only mitigate CWE-125: Out-of-bounds
Read~\footnote{\url{https://cwe.mitre.org/data/definitions/125.html}} and
CWE-787: Out-of-bounds
Write~\footnote{\url{https://cwe.mitre.org/data/definitions/787.html}}, for
dynamically allocated memory in the managed heap.

While this is stronger security than the equivalent non-CHERI versions of
these allocators, it is apparent that the CHERI allocators do not yet
take advantage of the full range of security mechanisms afforded by the
hardware. The next section goes on to explore potential security
vulnerabilities, mostly concerning temporal memory safety.


%%%%%


\section{Attacking Pure Capability Memory Allocators}
\label{sec:atk}

\input{./data/results/tests.tex}

%\begin{table}[t]
%\begin{center}
%\begin{tabular}{lcc}
%  \toprule
%Attack            & BSD simple & jemalloc \\
%\midrule
%narrow            & $\times$   & $\times$ \\
%narrow\_realloc   & $\times$   & $\times$ \\
%narrow\_widen     & $\times$   & $\times$ \\
%privesc           & $\times$   & $\times$ \\
%privesc2          &            & $\times$ \\
%undef             & $\times$   & $\times$ \\
%\bottomrule
%\end{tabular}
%\caption{Attacks which succeed on a given allocator are marked with a $\times$.}
%\label{tab:atks}
%\end{center}
%\end{table}

We came up with \numattacks{} potential memory allocator vulnerabilities, which
could be used to undermine the security guarantees offered by CHERI\@. We
prepared tests exercising each of these vulnerability, and execute them over
the allocators mentioned in~\autoref{sec:cheriallocators}, except those
allocators which have not passed our validation test. We observe a total of
\allocbugs{} attack successes (\autoref{tab:atks}), indicating potential CHERI
security violations.

Conceptually, the capability memory allocator vulnerabilities we identified
come in two flavours: the allocator can initially hand out more permissions
than expected; or can later be tricked in to escalating a capability's
privileges. As these undermine the security guarantees of using capabilities,
we refer to these issues as \emph{attacks}. In this section we start with three
serious attacks in the latter category, before detailing one minor attack in
the former category\andrei{Since we have names for these attacks, could we use
them, to refer back to the actual test sources}, as well as discuss theoretical
mitigations for each of the issues.

Formally speaking, CHERI capabilities have monotonically decreasing privileges:
in other words, when taking an existing capability \emph{C1} as input, any
capability \emph{C2} we derive from \emph{C1} must have the same or fewer
privileges. This may seem to make it impossible to increase a capability's
privileges, but software components can store high privilege capabilities that,
if misused, could give the appearance of returning a capability with increased
privileges. Due to the nature of memory allocators, they must be able to make
use of a higher-privileged capability in order to function.

Functions which take in a low privileged capability and use a higher privileged
capability\footnote{More formally, which take as input a capability \emph{C1}
and make internal use of a capability \emph{C2}, where \emph{C2}'s set of
privileges are not a subset of \emph{C1}'s privileges.} to perform calculations
are at risk of privilege escalation, and need to be carefully audited for bad
idioms.

\subsection{\privesc: Insufficient validation of the input capability}

Consider a memory allocator whose \fnc{realloc(cap, size)} function takes in a
capability \texttt{cap} whose address references the beginning of a block of
memory and returns a new capability whose address references the beginning of a
block of memory sufficient for storing \texttt{size} bytes.  A common
\fnc{realloc} optimisation is to avoid moving memory if the requested size fits
within the `bucket' that the block already resides within.  We might then write
a simple \fnc{realloc} as follows, assuming that we have access to a
high-privileged capability \texttt{MC} (e.g.~from
\fnc{mmap}~\cite{brooks19cheriabi}):

\begin{lstlisting}[language=C]
void *realloc(void *cap, size_of size) {
  if (size_of_bucket(cap) <= size) {
    // No need to reallocate.
    return cheri_bounds_set(
      cheri_address_set(MC, cap),
      size);
  } else {
    // Allocate a larger region of memory and copy
    // cap's contents over.
    ...
  }
}
\end{lstlisting}

\noindent The crucial optimisation is on line 2: if we already have enough
memory for the resized block, we simply return a new capability with the same
address as the original capability but with an increased upper bound. By
definition, reducing the size of a block means that it will always fit within
its existing bucket so the above optimisation is guaranteed to be correct.

Unfortunately this implementation of \fnc{realloc} is subject to privilege
escalation. For example, one can pass in a capability with narrow bounds and
receive back a capability with wider bounds:

\begin{lstlisting}[language=C]
uint8_t *arr = malloc(16);
arr = cheri_bounds_set(arr, 8);
assert(cheri_tag_get(arr) && cheri_length_get(arr) == 8);
arr = realloc(arr, 16);
assert(cheri_tag_get(arr) && cheri_length_get(arr) == 16);
\end{lstlisting}

We first \fnc{malloc} a block, returning a capability \emph{C1} with bounds
$0\ldots{}n$ bytes (line 1). We then derive a new capability \emph{C2} with
bounds $0\ldots{}m$ bytes where $m < n$ (lines 2 and 3). We can then use
\fnc{realloc} to turn \emph{C2} back into \emph{C1} -- even though we had
lost access to \emph{C1} entirely!

This is not just a theoretical attack: our example \fnc{realloc} is effectively
a simplified version of CheriBSD's \fnc{realloc}, which (as of
2021-08-18\footnote{\href{https://github.com/CTSRD-CHERI/cheribsd/issues/1065}{https://github.com/CTSRD-CHERI/cheribsd/issues/1065}})
is vulnerable to this attack. Any capability whose bounds contain the base
address of a memory block can potentially have its privileges escalated, with
\fnc{realloc} returning a capability with the same permissions as the memory
system's main capability (as well as widening bounds, this allows
e.g.~upgrading a read-only capability to a read/write capability).

\subsubsection{Mitigations}

Privilege escalation occurs when a function fails to fully validate a possibly
lower-privileged capability correctly before using a higher-privileged
capability. Exactly what validation should occur is highly situation dependent,
which is why it is easy to get wrong.

In most, perhaps all, reasonable cases, the input CHERI capability should be
authentic and the capability's address in-bounds. However, as our
\fnc{realloc} attack shows, these two conditions are necessary but not
sufficient.  For example, one solution to the \fnc{realloc} attack is to
check that \fnc{cap}'s address refers to the start of a memory block and
that the capability's permissions are equal to the permissions returned by the
most recent \fnc{malloc} or \fnc{realloc} for that memory block. This
implies that the memory allocator must either store, or be able to derive by
other means, the capability returned by the most recent \fnc{malloc} or
\fnc{realloc} call.

However, it may be too restrictive to restrict \fnc{realloc} to precisely
equal capabilities: one may wish to allow \emph{compatible} capabilities. The
definition of compatibility is then crucial, particularly as different CHERI
architectures have different bounds representations and permissions.

\subsection{\narrowwiden: Narrowing then widening}

Assuming that a child capability with narrow bounds has been derived while
respecting the issues raised in \narrowingdoesnt (\autoref{sec:narrow}), it may
seem that our issues with capability bounds are over. However, if one later
widens those bounds again, one may unintentionally leak secrets.

CheriBSD's default \fnc{realloc} is subject to this problem. The following
code executes successfully, with the capability returned by \fnc{realloc}
giving access to the same range of memory as the original \fnc{malloc}. Note
that \fnc{realloc} does not move, or scrub, memory in such a case. Thus, if
the user expected the setting of bounds to protect a secret, this code will not
give the protection expected.

\begin{lstlisting}[language=C]
uint8_t *arr = malloc(256);
for (uint8_t i = 0; i < 255; i++) arr[i] = i;
arr = realloc(arr, 1);
assert(cheri_tag_get(arr) && cheri_length_get(arr) == 1);
arr = realloc(arr, 256);
for (uint8_t i = 0; i < 255; i++) assert(arr[i] == i);
\end{lstlisting}


\subsubsection{Mitigations}

In the specific example above, \fnc{realloc} should scrub memory when the
size of a memory block is being narrowed. However, this may not be appropriate
in all cases, particularly where capability bounds narrowing is being used to
hide a secret from another compartment. In such cases, code which can widen a
capability's bounds must be carefully audited.


\subsection{\myundef: Authentic capabilities from undefined behaviour}

It is easy to assume that authentic capabilities can only be derived if one
follows CHERI-C's
\andrei{This is the first and only reference to this ``CHERI-C''}
rules correctly. However, it is possible for an attacker to use undefined
behaviour to derive authentic capabilities. Consider the following code:

\begin{lstlisting}[language=C]
uint8_t *c1 = malloc(16);
ptraddr_t c1_addr = cheri_address_get(c1);
uint8_t *c2 = cheri_bounds_set(c1, 8);

free(c2);
uint8_t *c3 = malloc(16);
assert(cheri_tag_get(c3) && cheri_length_get(c3) == 16);
assert(cheri_address_get(c3) == c1_addr);
\end{lstlisting}

In this example, we first derive a capability \emph{C1} with bounds of 16 bytes
(line 1) before deriving a narrower capability \emph{C2} from it (line 3). It
is then possible that after \fnc{free}ing the block of memory addressed by \emph{C1},
a subsequent \fnc{malloc} of 16 bytes returns a
capability \emph{C3} that is identical to \emph{C1}. This attack relies
on the underlying memory allocator reusing memory blocks, which many do in a
predictable fashion: this example runs successfully on CheriBSD (as of
2021-08-19).

Interestingly, C's pointer provenance rules mean that, after the code above has
executed, using \emph{C1} is no longer defined behaviour though this will not
trouble an attacker, who will find that most programs still execute as expected
and who now has a capability \emph{C3} giving the same access as \emph{C1}.


\subsubsection{Mitigations}

There are no general mitigations for \myundef. For the particular concrete
example, a partial mitigation is for \texttt{free} to scrub memory so that, at
least, whatever was present in the buffer cannot read by the attacker: however,
since the attack has in effect `aliased' the capability, future writes can be
observed and tampered with by the attacker.

A more complete mitigation for the concrete example is for \texttt{free} to
revoke all references to the capability. In other words, CHERI allows one to
scan memory looking for all capabilities with bounds encompassing an address
$p$ and render them inauthentic~\cite{xia29cherivoke}. In this case, this
means that the original code will then fail with a \texttt{SIGPROT} when it
tries to dereference \emph{C1}, downgrading the security leak into a
denial-of-service. However, scanning the stack and heap in order to perform
revocation is not likely to be a quick operation.


\subsection{\overlap: Returning capabilities whose bounds overlap with another block's}
\label{sec:overlap}

Capabilities have high and low bounds, which are a strong enforcement mechanism
for restricting the region of memory that the capability can access for
reading and writing. However, while small bounds can be precisely represented,
large bounds are over-approximated, raising the possibility of the capability
for one memory block having bounds which overlap with that of another nearby
memory block. For example, we expect that the following code never succeeds:

\begin{lstlisting}[language=C]
void *b1 = malloc(size);
void *b2 = malloc(size);
assert(
  cheri_base_get(b1) >= cheri_base_get(b2) &&
  cheri_base_get(b1) <
    cheri_base_get(b2) + cheri_length_get(f2)
);
}
\end{lstlisting}

The underlying issue is that capabilities have to be able to cover the full
span of virtual memory without having enough bits to do so precisely. For
example, Morello's capabilities have 31 bits to express the bounds for a 64-bit
address space. Modern CHERI systems use `CHERI
Concentrate'~\cite{woodruff19chericoncentrate} to encode bounds. A good analogy
is that CHERI Concentrate is similar IEEE 754 floating point numbers: the wider
the bound, the less accurately it will be represented. When a desired length
cannot be precisely represented, the next largest precisely representable
length is used in the bound. On Morello, 16,385 bytes is the smallest bound
which can not be precisely represented in a capability, and which is thus
rounded up to the next representable bound (in this case 16,392\footnote{For
CHERI RISC-V the first unrepresentable length is 4,097 bytes, which is rounded
up to 4,104.}).


\subsubsection{Mitigations}

There are three approaches that can ensure that narrowing bounds does not cause
secrets to be leaked.

First, one can check whether the narrowed bounds do/would capture only the
desired region of memory and if they don't/wouldn't, move the secret data to a
(probably new) non-overlapping region of memory. One can check whether bounds
will be adequately narrowed in advance using
\fnc{cheri\_representable\_length} or retrospectively by querying the
narrowed capability with \fnc{cheri\_length\_get}.

Second, one can lay out memory in advance such that, no matter what imprecise
bounds are used, secrets will not leak. In essence, this requires adding
padding to each object to take account of imprecise bounds. One could rewrite
\fnc{array\_with\_hidden\_secret} using this technique, provided that the
number of secret items at the end of the array does not vary after array
creation time.

These two approaches have different costs. The first approach requires users
only to pay for the cost of wasted memory if it is needed. However, at best
this introduces unexpected pauses as memory is allocated and copied. At worst,
this approach is infeasible --- one cannot, for example, easily move the
\emph{n}th element of a contiguous array because it is too big to be
represented with precise bounds. The second approach, in contrast, has fixed
up-front costs, but requires wasting memory for every object, even if no
future capability will ever have bounds covering it.

Third, one can abort execution if bounds cannot be precisely represented. The
\fnc{cheri\_bounds\_set\_exact} is a `safe' variant of
\fnc{cheri\_bounds\_set} which raises an error if bounds cannot be precisely
represented. We would prefer to see this be the standard bounds-setting
function, with a \fnc{cheri\_bounds\_set\_unsafe} variant allowing the
programmer to bypass bounds precision checks (because they are confident that
either: their bounds request can be precisely represented; or their code works
correctly with any resulting imprecision).

\jacob{Notably, occurrences of this pattern in real code will (as we've seen) be
much less obvious, and very hard to spot in code reviews. We could really do
with a helper that tests whether or not a hypothetical access would be
permitted, so we can write assertions in our \texttt{realloc} implementation, etc.}
\laurie{what would such a helper function look like?}


\subsection{Capability overflow}

\laurie{is this possible?}
\jacob{Not when used in the obvious way (e.g. dereferencing), but extreme
(65-bit) bounds behave in non-portable ways when queried explicitly, e.g.
saturating on Morello, and this isn't obvious in the CHERI API\@. This makes
manually testing the bounds difficult.}
\laurie{interesting! can we make a simple code example which shows this?}


\section{Conclusions}

\textbf{Acknowledgements:} We thank Ruben Ayrapetyan and David Chisnall for
comments.


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
